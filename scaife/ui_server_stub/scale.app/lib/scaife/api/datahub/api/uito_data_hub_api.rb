# Client code for the SCAIFE Datahub Module
#
# Generated by: https://openapi-generator.tech
# OpenAPI Generator version: 5.0.1
#
# <legal>
# SCALe version r.6.7.0.0.A
# 
# Copyright 2021 Carnegie Mellon University.
# 
# NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
# INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
# UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR
# IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF
# FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS
# OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT
# MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT,
# TRADEMARK, OR COPYRIGHT INFRINGEMENT.
# 
# Released under a MIT (SEI)-style license, please see COPYRIGHT file or
# contact permission@sei.cmu.edu for full terms.
# 
# [DISTRIBUTION STATEMENT A] This material has been approved for public
# release and unlimited distribution.  Please see Copyright notice for
# non-US Government use and distribution.
# 
# DM19-1274
# </legal>

require 'cgi'

module Scaife
module Api
module Datahub

  class UIToDataHubApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Add languages to the taxonomy condition objects
    # @param x_access_token [String] Token that contains information about the user
    # @param taxonomy_id [String] ID of the taxonomy to retrieve
    # @param condition_languages [ConditionLanguages] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def add_condition_languages(x_access_token, taxonomy_id, condition_languages, opts = {})
      add_condition_languages_with_http_info(x_access_token, taxonomy_id, condition_languages, opts)
      nil
    end

    # Add languages to the taxonomy condition objects
    # @param x_access_token [String] Token that contains information about the user
    # @param taxonomy_id [String] ID of the taxonomy to retrieve
    # @param condition_languages [ConditionLanguages] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def add_condition_languages_with_http_info(x_access_token, taxonomy_id, condition_languages, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.add_condition_languages ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.add_condition_languages"
      end
      # verify the required parameter 'taxonomy_id' is set
      if @api_client.config.client_side_validation && taxonomy_id.nil?
        fail ArgumentError, "Missing the required parameter 'taxonomy_id' when calling UIToDataHubApi.add_condition_languages"
      end
      # verify the required parameter 'condition_languages' is set
      if @api_client.config.client_side_validation && condition_languages.nil?
        fail ArgumentError, "Missing the required parameter 'condition_languages' when calling UIToDataHubApi.add_condition_languages"
      end
      # resource path
      local_var_path = '/taxonomies/{taxonomy_id}/languages'.sub('{' + 'taxonomy_id' + '}', CGI.escape(taxonomy_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(condition_languages)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.add_condition_languages",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#add_condition_languages\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Cascade determinations from a source into the project at the DataHub
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cascading_type Type of cascading to perform for this upload. Uses default if None provided.
    # @option opts [String] :cascading_project_id Use an existing DataHub project with this ID to perform the cascading.
    # @option opts [CascadingData] :cascading_data 
    # @return [CascadingPerformance]
    def cascade_determinations(x_access_token, project_id, opts = {})
      data, _status_code, _headers = cascade_determinations_with_http_info(x_access_token, project_id, opts)
      data
    end

    # Cascade determinations from a source into the project at the DataHub
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project
    # @param [Hash] opts the optional parameters
    # @option opts [String] :cascading_type Type of cascading to perform for this upload. Uses default if None provided.
    # @option opts [String] :cascading_project_id Use an existing DataHub project with this ID to perform the cascading.
    # @option opts [CascadingData] :cascading_data 
    # @return [Array<(CascadingPerformance, Integer, Hash)>] CascadingPerformance data, response status code and response headers
    def cascade_determinations_with_http_info(x_access_token, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.cascade_determinations ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.cascade_determinations"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling UIToDataHubApi.cascade_determinations"
      end
      allowable_values = ["diff", "precise"]
      if @api_client.config.client_side_validation && opts[:'cascading_type'] && !allowable_values.include?(opts[:'cascading_type'])
        fail ArgumentError, "invalid value for \"cascading_type\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/projects/{project_id}/cascade'.sub('{' + 'project_id' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['cascading_type'] = opts[:'cascading_type'] if !opts[:'cascading_type'].nil?
      form_params['cascading_project_id'] = opts[:'cascading_project_id'] if !opts[:'cascading_project_id'].nil?
      form_params['cascading_data'] = opts[:'cascading_data'] if !opts[:'cascading_data'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CascadingPerformance'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.cascade_determinations",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#cascade_determinations\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a new language definition.
    # @param x_access_token [String] Token that contains information about the user
    # @param language_metadata [LanguageMetadata] Language information
    # @param [Hash] opts the optional parameters
    # @return [CreatedLanguage]
    def create_language(x_access_token, language_metadata, opts = {})
      data, _status_code, _headers = create_language_with_http_info(x_access_token, language_metadata, opts)
      data
    end

    # Create a new language definition.
    # @param x_access_token [String] Token that contains information about the user
    # @param language_metadata [LanguageMetadata] Language information
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreatedLanguage, Integer, Hash)>] CreatedLanguage data, response status code and response headers
    def create_language_with_http_info(x_access_token, language_metadata, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.create_language ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.create_language"
      end
      # verify the required parameter 'language_metadata' is set
      if @api_client.config.client_side_validation && language_metadata.nil?
        fail ArgumentError, "Missing the required parameter 'language_metadata' when calling UIToDataHubApi.create_language"
      end
      # resource path
      local_var_path = '/languages'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(language_metadata)

      # return_type
      return_type = opts[:debug_return_type] || 'CreatedLanguage'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.create_language",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#create_language\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a new package. This request will return the package_id used to reference the package within the DataHub. Note, for metrics data uploads use PUT /tools/{tool_id}.
    # @param x_access_token [String] Token that contains information about the user
    # @param package_metadata [PackageMetadata] Data to the create package
    # @param [Hash] opts the optional parameters
    # @return [CreatedPackage]
    def create_package(x_access_token, package_metadata, opts = {})
      data, _status_code, _headers = create_package_with_http_info(x_access_token, package_metadata, opts)
      data
    end

    # Create a new package. This request will return the package_id used to reference the package within the DataHub. Note, for metrics data uploads use PUT /tools/{tool_id}.
    # @param x_access_token [String] Token that contains information about the user
    # @param package_metadata [PackageMetadata] Data to the create package
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreatedPackage, Integer, Hash)>] CreatedPackage data, response status code and response headers
    def create_package_with_http_info(x_access_token, package_metadata, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.create_package ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.create_package"
      end
      # verify the required parameter 'package_metadata' is set
      if @api_client.config.client_side_validation && package_metadata.nil?
        fail ArgumentError, "Missing the required parameter 'package_metadata' when calling UIToDataHubApi.create_package"
      end
      # resource path
      local_var_path = '/packages'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(package_metadata)

      # return_type
      return_type = opts[:debug_return_type] || 'CreatedPackage'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.create_package",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#create_package\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a new project. The package and taxonomies should be uploaded to the DataHub prior to creating a project. This request will return the project_id to reference the project within the DataHub.
    # @param x_access_token [String] Token that contains information about the user
    # @param project_metadata [ProjectMetadata] Data to a create project
    # @param [Hash] opts the optional parameters
    # @return [CreatedProject]
    def create_project(x_access_token, project_metadata, opts = {})
      data, _status_code, _headers = create_project_with_http_info(x_access_token, project_metadata, opts)
      data
    end

    # Create a new project. The package and taxonomies should be uploaded to the DataHub prior to creating a project. This request will return the project_id to reference the project within the DataHub.
    # @param x_access_token [String] Token that contains information about the user
    # @param project_metadata [ProjectMetadata] Data to a create project
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreatedProject, Integer, Hash)>] CreatedProject data, response status code and response headers
    def create_project_with_http_info(x_access_token, project_metadata, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.create_project ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.create_project"
      end
      # verify the required parameter 'project_metadata' is set
      if @api_client.config.client_side_validation && project_metadata.nil?
        fail ArgumentError, "Missing the required parameter 'project_metadata' when calling UIToDataHubApi.create_project"
      end
      # resource path
      local_var_path = '/projects'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(project_metadata)

      # return_type
      return_type = opts[:debug_return_type] || 'CreatedProject'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.create_project",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#create_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload a new taxonomy to the DataHub Module. Returns the taxonomy_id and condition_ids to reference this Taxonomy and its Conditions.
    # @param x_access_token [String] Token that contains information about the user
    # @param taxonomy_metadata [TaxonomyMetadata] Taxonomy information to upload
    # @param [Hash] opts the optional parameters
    # @return [CreatedTaxonomy]
    def create_taxonomy(x_access_token, taxonomy_metadata, opts = {})
      data, _status_code, _headers = create_taxonomy_with_http_info(x_access_token, taxonomy_metadata, opts)
      data
    end

    # Upload a new taxonomy to the DataHub Module. Returns the taxonomy_id and condition_ids to reference this Taxonomy and its Conditions.
    # @param x_access_token [String] Token that contains information about the user
    # @param taxonomy_metadata [TaxonomyMetadata] Taxonomy information to upload
    # @param [Hash] opts the optional parameters
    # @return [Array<(CreatedTaxonomy, Integer, Hash)>] CreatedTaxonomy data, response status code and response headers
    def create_taxonomy_with_http_info(x_access_token, taxonomy_metadata, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.create_taxonomy ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.create_taxonomy"
      end
      # verify the required parameter 'taxonomy_metadata' is set
      if @api_client.config.client_side_validation && taxonomy_metadata.nil?
        fail ArgumentError, "Missing the required parameter 'taxonomy_metadata' when calling UIToDataHubApi.create_taxonomy"
      end
      # resource path
      local_var_path = '/taxonomies'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(taxonomy_metadata)

      # return_type
      return_type = opts[:debug_return_type] || 'CreatedTaxonomy'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.create_taxonomy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#create_taxonomy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a Test Suite in the DataHub Module.
    # @param x_access_token [String] Token that contains information about the user
    # @param test_suite_metadata [TestSuiteMetadata] Test Suite information to upload
    # @param [Hash] opts the optional parameters
    # @return [TestSuiteHeading]
    def create_test_suite(x_access_token, test_suite_metadata, opts = {})
      data, _status_code, _headers = create_test_suite_with_http_info(x_access_token, test_suite_metadata, opts)
      data
    end

    # Create a Test Suite in the DataHub Module.
    # @param x_access_token [String] Token that contains information about the user
    # @param test_suite_metadata [TestSuiteMetadata] Test Suite information to upload
    # @param [Hash] opts the optional parameters
    # @return [Array<(TestSuiteHeading, Integer, Hash)>] TestSuiteHeading data, response status code and response headers
    def create_test_suite_with_http_info(x_access_token, test_suite_metadata, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.create_test_suite ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.create_test_suite"
      end
      # verify the required parameter 'test_suite_metadata' is set
      if @api_client.config.client_side_validation && test_suite_metadata.nil?
        fail ArgumentError, "Missing the required parameter 'test_suite_metadata' when calling UIToDataHubApi.create_test_suite"
      end
      # resource path
      local_var_path = '/test_suites'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(test_suite_metadata)

      # return_type
      return_type = opts[:debug_return_type] || 'TestSuiteHeading'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.create_test_suite",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#create_test_suite\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an existing package.
    # @param x_access_token [String] Token that contains information about the user
    # @param package_id [String] ID of the package to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_package(x_access_token, package_id, opts = {})
      delete_package_with_http_info(x_access_token, package_id, opts)
      nil
    end

    # Delete an existing package.
    # @param x_access_token [String] Token that contains information about the user
    # @param package_id [String] ID of the package to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_package_with_http_info(x_access_token, package_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.delete_package ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.delete_package"
      end
      # verify the required parameter 'package_id' is set
      if @api_client.config.client_side_validation && package_id.nil?
        fail ArgumentError, "Missing the required parameter 'package_id' when calling UIToDataHubApi.delete_package"
      end
      # resource path
      local_var_path = '/packages/{package_id}'.sub('{' + 'package_id' + '}', CGI.escape(package_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.delete_package",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#delete_package\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Delete an existing project.
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project to delete
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def delete_project(x_access_token, project_id, opts = {})
      delete_project_with_http_info(x_access_token, project_id, opts)
      nil
    end

    # Delete an existing project.
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project to delete
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def delete_project_with_http_info(x_access_token, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.delete_project ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.delete_project"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling UIToDataHubApi.delete_project"
      end
      # resource path
      local_var_path = '/projects/{project_id}'.sub('{' + 'project_id' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.delete_project",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:DELETE, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#delete_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an existing package. Use this method to add new alerts for the package. Note, for metrics data or tool output file uploads use POST /tools/{tool_id}/packages/{package_id}.
    # @param x_access_token [String] Token that contains information about the user
    # @param package_id [String] ID of the package to update
    # @param edit_package_metadata [EditPackageMetadata] Package data to modify the existing package with
    # @param [Hash] opts the optional parameters
    # @return [EditedPackage]
    def edit_package(x_access_token, package_id, edit_package_metadata, opts = {})
      data, _status_code, _headers = edit_package_with_http_info(x_access_token, package_id, edit_package_metadata, opts)
      data
    end

    # Update an existing package. Use this method to add new alerts for the package. Note, for metrics data or tool output file uploads use POST /tools/{tool_id}/packages/{package_id}.
    # @param x_access_token [String] Token that contains information about the user
    # @param package_id [String] ID of the package to update
    # @param edit_package_metadata [EditPackageMetadata] Package data to modify the existing package with
    # @param [Hash] opts the optional parameters
    # @return [Array<(EditedPackage, Integer, Hash)>] EditedPackage data, response status code and response headers
    def edit_package_with_http_info(x_access_token, package_id, edit_package_metadata, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.edit_package ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.edit_package"
      end
      # verify the required parameter 'package_id' is set
      if @api_client.config.client_side_validation && package_id.nil?
        fail ArgumentError, "Missing the required parameter 'package_id' when calling UIToDataHubApi.edit_package"
      end
      # verify the required parameter 'edit_package_metadata' is set
      if @api_client.config.client_side_validation && edit_package_metadata.nil?
        fail ArgumentError, "Missing the required parameter 'edit_package_metadata' when calling UIToDataHubApi.edit_package"
      end
      # resource path
      local_var_path = '/packages/{package_id}'.sub('{' + 'package_id' + '}', CGI.escape(package_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(edit_package_metadata)

      # return_type
      return_type = opts[:debug_return_type] || 'EditedPackage'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.edit_package",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#edit_package\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Update an existing project. This method can also be used to send only meta-alert determinations of an existing meta-alert to the DataHub, which is most useful when a project has an open adaptive heuristic set.
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project to update
    # @param edit_project_metadata [EditProjectMetadata] Project data to modify the existing project with
    # @param [Hash] opts the optional parameters
    # @return [EditedProject]
    def edit_project(x_access_token, project_id, edit_project_metadata, opts = {})
      data, _status_code, _headers = edit_project_with_http_info(x_access_token, project_id, edit_project_metadata, opts)
      data
    end

    # Update an existing project. This method can also be used to send only meta-alert determinations of an existing meta-alert to the DataHub, which is most useful when a project has an open adaptive heuristic set.
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project to update
    # @param edit_project_metadata [EditProjectMetadata] Project data to modify the existing project with
    # @param [Hash] opts the optional parameters
    # @return [Array<(EditedProject, Integer, Hash)>] EditedProject data, response status code and response headers
    def edit_project_with_http_info(x_access_token, project_id, edit_project_metadata, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.edit_project ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.edit_project"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling UIToDataHubApi.edit_project"
      end
      # verify the required parameter 'edit_project_metadata' is set
      if @api_client.config.client_side_validation && edit_project_metadata.nil?
        fail ArgumentError, "Missing the required parameter 'edit_project_metadata' when calling UIToDataHubApi.edit_project"
      end
      # resource path
      local_var_path = '/projects/{project_id}'.sub('{' + 'project_id' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(edit_project_metadata)

      # return_type
      return_type = opts[:debug_return_type] || 'EditedProject'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.edit_project",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#edit_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Edit a taxonomy, including uploads of additional conditions
    # @param x_access_token [String] Token that contains information about the user
    # @param taxonomy_id [String] ID of the taxonomy to retrieve
    # @param edit_taxonomy [EditTaxonomy] Taxonomy information to upload
    # @param [Hash] opts the optional parameters
    # @return [Array<ConditionResponseWId>]
    def edit_taxonomy(x_access_token, taxonomy_id, edit_taxonomy, opts = {})
      data, _status_code, _headers = edit_taxonomy_with_http_info(x_access_token, taxonomy_id, edit_taxonomy, opts)
      data
    end

    # Edit a taxonomy, including uploads of additional conditions
    # @param x_access_token [String] Token that contains information about the user
    # @param taxonomy_id [String] ID of the taxonomy to retrieve
    # @param edit_taxonomy [EditTaxonomy] Taxonomy information to upload
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<ConditionResponseWId>, Integer, Hash)>] Array<ConditionResponseWId> data, response status code and response headers
    def edit_taxonomy_with_http_info(x_access_token, taxonomy_id, edit_taxonomy, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.edit_taxonomy ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.edit_taxonomy"
      end
      # verify the required parameter 'taxonomy_id' is set
      if @api_client.config.client_side_validation && taxonomy_id.nil?
        fail ArgumentError, "Missing the required parameter 'taxonomy_id' when calling UIToDataHubApi.edit_taxonomy"
      end
      # verify the required parameter 'edit_taxonomy' is set
      if @api_client.config.client_side_validation && edit_taxonomy.nil?
        fail ArgumentError, "Missing the required parameter 'edit_taxonomy' when calling UIToDataHubApi.edit_taxonomy"
      end
      # resource path
      local_var_path = '/taxonomies/{taxonomy_id}'.sub('{' + 'taxonomy_id' + '}', CGI.escape(taxonomy_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(edit_taxonomy)

      # return_type
      return_type = opts[:debug_return_type] || 'Array<ConditionResponseWId>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.edit_taxonomy",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:PUT, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#edit_taxonomy\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Edit metadata for a tool and/or upload a CSV with checker mappings
    # @param x_access_token [String] Token that contains information about the user
    # @param tool_id [String] Tool ID to update data
    # @param [Hash] opts the optional parameters
    # @option opts [BaseTool] :tool_metadata 
    # @option opts [File] :checker_mappings_csv 
    # @return [ToolResponse]
    def edit_tool(x_access_token, tool_id, opts = {})
      data, _status_code, _headers = edit_tool_with_http_info(x_access_token, tool_id, opts)
      data
    end

    # Edit metadata for a tool and/or upload a CSV with checker mappings
    # @param x_access_token [String] Token that contains information about the user
    # @param tool_id [String] Tool ID to update data
    # @param [Hash] opts the optional parameters
    # @option opts [BaseTool] :tool_metadata 
    # @option opts [File] :checker_mappings_csv 
    # @return [Array<(ToolResponse, Integer, Hash)>] ToolResponse data, response status code and response headers
    def edit_tool_with_http_info(x_access_token, tool_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.edit_tool ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.edit_tool"
      end
      # verify the required parameter 'tool_id' is set
      if @api_client.config.client_side_validation && tool_id.nil?
        fail ArgumentError, "Missing the required parameter 'tool_id' when calling UIToDataHubApi.edit_tool"
      end
      # resource path
      local_var_path = '/tools/{tool_id}'.sub('{' + 'tool_id' + '}', CGI.escape(tool_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['tool_metadata'] = opts[:'tool_metadata'] if !opts[:'tool_metadata'].nil?
      form_params['checker_mappings_csv'] = opts[:'checker_mappings_csv'] if !opts[:'checker_mappings_csv'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'ToolResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.edit_tool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#edit_tool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send a request to the DataHub to enable data forwarding for all future updates to this project
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project to enable data forwarding
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def enable_data_forwarding(x_access_token, project_id, opts = {})
      enable_data_forwarding_with_http_info(x_access_token, project_id, opts)
      nil
    end

    # Send a request to the DataHub to enable data forwarding for all future updates to this project
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project to enable data forwarding
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def enable_data_forwarding_with_http_info(x_access_token, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.enable_data_forwarding ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.enable_data_forwarding"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling UIToDataHubApi.enable_data_forwarding"
      end
      # resource path
      local_var_path = '/projects/{project_id}'.sub('{' + 'project_id' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.enable_data_forwarding",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#enable_data_forwarding\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the last performance metrics for cascading determinations on this project
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project
    # @param [Hash] opts the optional parameters
    # @return [CascadingPerformance]
    def get_cascade_performance(x_access_token, project_id, opts = {})
      data, _status_code, _headers = get_cascade_performance_with_http_info(x_access_token, project_id, opts)
      data
    end

    # Get the last performance metrics for cascading determinations on this project
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project
    # @param [Hash] opts the optional parameters
    # @return [Array<(CascadingPerformance, Integer, Hash)>] CascadingPerformance data, response status code and response headers
    def get_cascade_performance_with_http_info(x_access_token, project_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.get_cascade_performance ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.get_cascade_performance"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling UIToDataHubApi.get_cascade_performance"
      end
      # resource path
      local_var_path = '/projects/{project_id}/cascade'.sub('{' + 'project_id' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'CascadingPerformance'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.get_cascade_performance",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#get_cascade_performance\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Retrieve projects from the DataHub. Send taxonomy information the requestor already has, along with projects it is requesting. This way, a response from the DataHub can efficiently leave out taxonomies that the requestor already has information for.
    # @param x_access_token [String] Token that contains information about the user
    # @param projects_requested [ProjectsRequested] &#39;Taxonomy information the requesting module already has, along with projects it is requesting.&#39;
    # @param [Hash] opts the optional parameters
    # @return [Array<Project>]
    def get_projects(x_access_token, projects_requested, opts = {})
      data, _status_code, _headers = get_projects_with_http_info(x_access_token, projects_requested, opts)
      data
    end

    # Retrieve projects from the DataHub. Send taxonomy information the requestor already has, along with projects it is requesting. This way, a response from the DataHub can efficiently leave out taxonomies that the requestor already has information for.
    # @param x_access_token [String] Token that contains information about the user
    # @param projects_requested [ProjectsRequested] &#39;Taxonomy information the requesting module already has, along with projects it is requesting.&#39;
    # @param [Hash] opts the optional parameters
    # @return [Array<(Array<Project>, Integer, Hash)>] Array<Project> data, response status code and response headers
    def get_projects_with_http_info(x_access_token, projects_requested, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.get_projects ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.get_projects"
      end
      # verify the required parameter 'projects_requested' is set
      if @api_client.config.client_side_validation && projects_requested.nil?
        fail ArgumentError, "Missing the required parameter 'projects_requested' when calling UIToDataHubApi.get_projects"
      end
      # resource path
      local_var_path = '/projects/retrieve'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(projects_requested)

      # return_type
      return_type = opts[:debug_return_type] || 'Array<Project>'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.get_projects",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#get_projects\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Send updated meta-alert determinations for a specific project.
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project
    # @param meta_alert_determination [Array<MetaAlertDetermination>] The list of meta-alert IDs and determinations
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def send_meta_alerts_for_project(x_access_token, project_id, meta_alert_determination, opts = {})
      send_meta_alerts_for_project_with_http_info(x_access_token, project_id, meta_alert_determination, opts)
      nil
    end

    # Send updated meta-alert determinations for a specific project.
    # @param x_access_token [String] Token that contains information about the user
    # @param project_id [String] The ID of the project
    # @param meta_alert_determination [Array<MetaAlertDetermination>] The list of meta-alert IDs and determinations
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def send_meta_alerts_for_project_with_http_info(x_access_token, project_id, meta_alert_determination, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.send_meta_alerts_for_project ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.send_meta_alerts_for_project"
      end
      # verify the required parameter 'project_id' is set
      if @api_client.config.client_side_validation && project_id.nil?
        fail ArgumentError, "Missing the required parameter 'project_id' when calling UIToDataHubApi.send_meta_alerts_for_project"
      end
      # verify the required parameter 'meta_alert_determination' is set
      if @api_client.config.client_side_validation && meta_alert_determination.nil?
        fail ArgumentError, "Missing the required parameter 'meta_alert_determination' when calling UIToDataHubApi.send_meta_alerts_for_project"
      end
      # resource path
      local_var_path = '/projects/{project_id}/determinations'.sub('{' + 'project_id' + '}', CGI.escape(project_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(meta_alert_determination)

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.send_meta_alerts_for_project",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#send_meta_alerts_for_project\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload a Source Code Archive and MetaData Files for the Package.
    # @param x_access_token [String] Token that contains information about the user
    # @param package_id [String] ID of the package to update
    # @param sourcecode_archive [File] Source Code Archive for this package
    # @param [Hash] opts the optional parameters
    # @option opts [File] :source_file_csv Source File CSV
    # @option opts [File] :source_function_csv Source Function CSV
    # @return [nil]
    def upload_codebase_for_package(x_access_token, package_id, sourcecode_archive, opts = {})
      upload_codebase_for_package_with_http_info(x_access_token, package_id, sourcecode_archive, opts)
      nil
    end

    # Upload a Source Code Archive and MetaData Files for the Package.
    # @param x_access_token [String] Token that contains information about the user
    # @param package_id [String] ID of the package to update
    # @param sourcecode_archive [File] Source Code Archive for this package
    # @param [Hash] opts the optional parameters
    # @option opts [File] :source_file_csv Source File CSV
    # @option opts [File] :source_function_csv Source Function CSV
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def upload_codebase_for_package_with_http_info(x_access_token, package_id, sourcecode_archive, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.upload_codebase_for_package ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.upload_codebase_for_package"
      end
      # verify the required parameter 'package_id' is set
      if @api_client.config.client_side_validation && package_id.nil?
        fail ArgumentError, "Missing the required parameter 'package_id' when calling UIToDataHubApi.upload_codebase_for_package"
      end
      # verify the required parameter 'sourcecode_archive' is set
      if @api_client.config.client_side_validation && sourcecode_archive.nil?
        fail ArgumentError, "Missing the required parameter 'sourcecode_archive' when calling UIToDataHubApi.upload_codebase_for_package"
      end
      # resource path
      local_var_path = '/packages/{package_id}'.sub('{' + 'package_id' + '}', CGI.escape(package_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['sourcecode_archive'] = sourcecode_archive
      form_params['source_file_csv'] = opts[:'source_file_csv'] if !opts[:'source_file_csv'].nil?
      form_params['source_function_csv'] = opts[:'source_function_csv'] if !opts[:'source_function_csv'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.upload_codebase_for_package",
        :sourcecode_archive => "",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#upload_codebase_for_package\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload Test Suite MetaData Files
    # @param x_access_token [String] Token that contains information about the user
    # @param test_suite_id [String] Test Suite ID to upload data files
    # @param package_id [String] Package ID to upload data files
    # @param manifest_file [File] Manifest for this test suite
    # @param [Hash] opts the optional parameters
    # @option opts [File] :source_file_csv Source File CSV
    # @option opts [File] :source_function_csv Source Function CSV
    # @option opts [File] :use_license_file Use License for this test suite
    # @return [nil]
    def upload_test_suite(x_access_token, test_suite_id, package_id, manifest_file, opts = {})
      upload_test_suite_with_http_info(x_access_token, test_suite_id, package_id, manifest_file, opts)
      nil
    end

    # Upload Test Suite MetaData Files
    # @param x_access_token [String] Token that contains information about the user
    # @param test_suite_id [String] Test Suite ID to upload data files
    # @param package_id [String] Package ID to upload data files
    # @param manifest_file [File] Manifest for this test suite
    # @param [Hash] opts the optional parameters
    # @option opts [File] :source_file_csv Source File CSV
    # @option opts [File] :source_function_csv Source Function CSV
    # @option opts [File] :use_license_file Use License for this test suite
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def upload_test_suite_with_http_info(x_access_token, test_suite_id, package_id, manifest_file, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.upload_test_suite ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.upload_test_suite"
      end
      # verify the required parameter 'test_suite_id' is set
      if @api_client.config.client_side_validation && test_suite_id.nil?
        fail ArgumentError, "Missing the required parameter 'test_suite_id' when calling UIToDataHubApi.upload_test_suite"
      end
      # verify the required parameter 'package_id' is set
      if @api_client.config.client_side_validation && package_id.nil?
        fail ArgumentError, "Missing the required parameter 'package_id' when calling UIToDataHubApi.upload_test_suite"
      end
      # verify the required parameter 'manifest_file' is set
      if @api_client.config.client_side_validation && manifest_file.nil?
        fail ArgumentError, "Missing the required parameter 'manifest_file' when calling UIToDataHubApi.upload_test_suite"
      end
      # resource path
      local_var_path = '/test_suites/{test_suite_id}/packages/{package_id}'.sub('{' + 'test_suite_id' + '}', CGI.escape(test_suite_id.to_s)).sub('{' + 'package_id' + '}', CGI.escape(package_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['manifest_file'] = manifest_file
      form_params['source_file_csv'] = opts[:'source_file_csv'] if !opts[:'source_file_csv'].nil?
      form_params['source_function_csv'] = opts[:'source_function_csv'] if !opts[:'source_function_csv'].nil?
      form_params['use_license_file'] = opts[:'use_license_file'] if !opts[:'use_license_file'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.upload_test_suite",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#upload_test_suite\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload a new Tool to the DataHub Module. Returns a tool_id to reference the tool in the DataHub Module. For code metrics tools, upload a list of ordered field names.
    # @param x_access_token [String] Token that contains information about the user
    # @param tool_metadata [ToolMetadata] Tool information to upload
    # @param [Hash] opts the optional parameters
    # @return [ToolResponse]
    def upload_tool(x_access_token, tool_metadata, opts = {})
      data, _status_code, _headers = upload_tool_with_http_info(x_access_token, tool_metadata, opts)
      data
    end

    # Upload a new Tool to the DataHub Module. Returns a tool_id to reference the tool in the DataHub Module. For code metrics tools, upload a list of ordered field names.
    # @param x_access_token [String] Token that contains information about the user
    # @param tool_metadata [ToolMetadata] Tool information to upload
    # @param [Hash] opts the optional parameters
    # @return [Array<(ToolResponse, Integer, Hash)>] ToolResponse data, response status code and response headers
    def upload_tool_with_http_info(x_access_token, tool_metadata, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.upload_tool ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.upload_tool"
      end
      # verify the required parameter 'tool_metadata' is set
      if @api_client.config.client_side_validation && tool_metadata.nil?
        fail ArgumentError, "Missing the required parameter 'tool_metadata' when calling UIToDataHubApi.upload_tool"
      end
      # resource path
      local_var_path = '/tools'

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['application/json'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(tool_metadata)

      # return_type
      return_type = opts[:debug_return_type] || 'ToolResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.upload_tool",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#upload_tool\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Upload Tool Output and Metrics Tool CSVs
    # @param x_access_token [String] Token that contains information about the user
    # @param tool_id [String] Tool ID to upload data
    # @param package_id [String] Package ID to upload data
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metrics_tool_format Metrics tool used to produce the CSV
    # @option opts [String] :ffsa_tool_format Format used in the FFSA tool output
    # @option opts [File] :tool_output_file Tool Output File to Upload to the DataHub
    # @return [TaskStatus]
    def upload_tool_output(x_access_token, tool_id, package_id, opts = {})
      data, _status_code, _headers = upload_tool_output_with_http_info(x_access_token, tool_id, package_id, opts)
      data
    end

    # Upload Tool Output and Metrics Tool CSVs
    # @param x_access_token [String] Token that contains information about the user
    # @param tool_id [String] Tool ID to upload data
    # @param package_id [String] Package ID to upload data
    # @param [Hash] opts the optional parameters
    # @option opts [String] :metrics_tool_format Metrics tool used to produce the CSV
    # @option opts [String] :ffsa_tool_format Format used in the FFSA tool output
    # @option opts [File] :tool_output_file Tool Output File to Upload to the DataHub
    # @return [Array<(TaskStatus, Integer, Hash)>] TaskStatus data, response status code and response headers
    def upload_tool_output_with_http_info(x_access_token, tool_id, package_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: UIToDataHubApi.upload_tool_output ...'
      end
      # verify the required parameter 'x_access_token' is set
      if @api_client.config.client_side_validation && x_access_token.nil?
        fail ArgumentError, "Missing the required parameter 'x_access_token' when calling UIToDataHubApi.upload_tool_output"
      end
      # verify the required parameter 'tool_id' is set
      if @api_client.config.client_side_validation && tool_id.nil?
        fail ArgumentError, "Missing the required parameter 'tool_id' when calling UIToDataHubApi.upload_tool_output"
      end
      # verify the required parameter 'package_id' is set
      if @api_client.config.client_side_validation && package_id.nil?
        fail ArgumentError, "Missing the required parameter 'package_id' when calling UIToDataHubApi.upload_tool_output"
      end
      allowable_values = ["ccsm", "lizard", "understand"]
      if @api_client.config.client_side_validation && opts[:'metrics_tool_format'] && !allowable_values.include?(opts[:'metrics_tool_format'])
        fail ArgumentError, "invalid value for \"metrics_tool_format\", must be one of #{allowable_values}"
      end
      allowable_values = ["raw", "scarf", "swamp"]
      if @api_client.config.client_side_validation && opts[:'ffsa_tool_format'] && !allowable_values.include?(opts[:'ffsa_tool_format'])
        fail ArgumentError, "invalid value for \"ffsa_tool_format\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/tools/{tool_id}/packages/{package_id}'.sub('{' + 'tool_id' + '}', CGI.escape(tool_id.to_s)).sub('{' + 'package_id' + '}', CGI.escape(package_id.to_s))

      # query parameters
      query_params = opts[:query_params] || {}

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      header_params['Content-Type'] = @api_client.select_header_content_type(['multipart/form-data'])
      header_params[:'x_access_token'] = x_access_token

      # form parameters
      form_params = opts[:form_params] || {}
      form_params['metrics_tool_format'] = opts[:'metrics_tool_format'] if !opts[:'metrics_tool_format'].nil?
      form_params['ffsa_tool_format'] = opts[:'ffsa_tool_format'] if !opts[:'ffsa_tool_format'].nil?
      form_params['tool_output_file'] = opts[:'tool_output_file'] if !opts[:'tool_output_file'].nil?

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'TaskStatus'

      # auth_names
      auth_names = opts[:debug_auth_names] || []

      new_options = opts.merge(
        :operation => :"UIToDataHubApi.upload_tool_output",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: UIToDataHubApi#upload_tool_output\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end

end
end
end
